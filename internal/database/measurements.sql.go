// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: measurements.sql

package database

import (
	"context"
	"time"
)

const createMeasurement = `-- name: CreateMeasurement :one
INSERT INTO measurements(
id,
created_at,
measurement_date,
measurement_time, 
pressure_1,
pressure_2,
temperature_1,
temperature_2)
VALUES (
	gen_random_uuid(),
	NOW(),
	$1,
	$2,
	$3,
	$4,
	$5,
	$6
	)
RETURNING id, created_at, measurement_date, measurement_time, pressure_1, pressure_2, temperature_1, temperature_2
`

type CreateMeasurementParams struct {
	MeasurementDate time.Time
	MeasurementTime time.Time
	Pressure1       string
	Pressure2       string
	Temperature1    string
	Temperature2    string
}

func (q *Queries) CreateMeasurement(ctx context.Context, arg CreateMeasurementParams) (Measurement, error) {
	row := q.db.QueryRowContext(ctx, createMeasurement,
		arg.MeasurementDate,
		arg.MeasurementTime,
		arg.Pressure1,
		arg.Pressure2,
		arg.Temperature1,
		arg.Temperature2,
	)
	var i Measurement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.MeasurementDate,
		&i.MeasurementTime,
		&i.Pressure1,
		&i.Pressure2,
		&i.Temperature1,
		&i.Temperature2,
	)
	return i, err
}

const getMeasurements = `-- name: GetMeasurements :many
SELECT id, created_at, measurement_date, measurement_time, pressure_1, pressure_2, temperature_1, temperature_2
FROM measurements
ORDER BY measurement_date
`

func (q *Queries) GetMeasurements(ctx context.Context) ([]Measurement, error) {
	rows, err := q.db.QueryContext(ctx, getMeasurements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Measurement
	for rows.Next() {
		var i Measurement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.MeasurementDate,
			&i.MeasurementTime,
			&i.Pressure1,
			&i.Pressure2,
			&i.Temperature1,
			&i.Temperature2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeasurementsByDate = `-- name: GetMeasurementsByDate :many
SELECT id, created_at, measurement_date, measurement_time, pressure_1, pressure_2, temperature_1, temperature_2
FROM measurements
WHERE measurement_date BETWEEN $1 AND $2
`

type GetMeasurementsByDateParams struct {
	MeasurementDate   time.Time
	MeasurementDate_2 time.Time
}

func (q *Queries) GetMeasurementsByDate(ctx context.Context, arg GetMeasurementsByDateParams) ([]Measurement, error) {
	rows, err := q.db.QueryContext(ctx, getMeasurementsByDate, arg.MeasurementDate, arg.MeasurementDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Measurement
	for rows.Next() {
		var i Measurement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.MeasurementDate,
			&i.MeasurementTime,
			&i.Pressure1,
			&i.Pressure2,
			&i.Temperature1,
			&i.Temperature2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
