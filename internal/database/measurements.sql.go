// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: measurements.sql

package database

import (
	"context"
	"time"

	"github.com/lib/pq"
)

const createMeasurement = `-- name: CreateMeasurement :one
INSERT INTO measurements(
id,
created_at,
measurement_date,
measurement_time, 
pressure_1,
pressure_2,
temperature_1,
temperature_2)
VALUES (
	gen_random_uuid(),
	NOW(),
	$1,
	$2,
	$3,
	$4,
	$5,
	$6
	)
RETURNING id, created_at, measurement_date, measurement_time, pressure_1, pressure_2, temperature_1, temperature_2
`

type CreateMeasurementParams struct {
	MeasurementDate time.Time
	MeasurementTime time.Time
	Pressure1       float64
	Pressure2       float64
	Temperature1    float64
	Temperature2    float64
}

func (q *Queries) CreateMeasurement(ctx context.Context, arg CreateMeasurementParams) (Measurement, error) {
	row := q.db.QueryRowContext(ctx, createMeasurement,
		arg.MeasurementDate,
		arg.MeasurementTime,
		arg.Pressure1,
		arg.Pressure2,
		arg.Temperature1,
		arg.Temperature2,
	)
	var i Measurement
	err := row.Scan(
		&i.ID,
		&i.CreatedAt,
		&i.MeasurementDate,
		&i.MeasurementTime,
		&i.Pressure1,
		&i.Pressure2,
		&i.Temperature1,
		&i.Temperature2,
	)
	return i, err
}

const createMeasurementsBatch = `-- name: CreateMeasurementsBatch :exec
INSERT INTO measurements(
	id,
	created_at,
	measurement_date,
	measurement_time,
	pressure_1,
	pressure_2,
	temperature_1,
	temperature_2)
VALUES(
	gen_random_uuid(),
	NOW(),
	unnest($1::DATE[]),
    	unnest($2::TIME[]),
    	unnest($3::FLOAT8[]),
    	unnest($4::FLOAT8[]),
    	unnest($5::FLOAT8[]),
    	unnest($6::FLOAT8[])
	)
`

type CreateMeasurementsBatchParams struct {
	Column1 []time.Time
	Column2 []time.Time
	Column3 []float64
	Column4 []float64
	Column5 []float64
	Column6 []float64
}

func (q *Queries) CreateMeasurementsBatch(ctx context.Context, arg CreateMeasurementsBatchParams) error {
	_, err := q.db.ExecContext(ctx, createMeasurementsBatch,
		pq.Array(arg.Column1),
		pq.Array(arg.Column2),
		pq.Array(arg.Column3),
		pq.Array(arg.Column4),
		pq.Array(arg.Column5),
		pq.Array(arg.Column6),
	)
	return err
}

const getMeasurements = `-- name: GetMeasurements :many
SELECT id, created_at, measurement_date, measurement_time, pressure_1, pressure_2, temperature_1, temperature_2
FROM measurements
ORDER BY measurement_date
`

func (q *Queries) GetMeasurements(ctx context.Context) ([]Measurement, error) {
	rows, err := q.db.QueryContext(ctx, getMeasurements)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Measurement
	for rows.Next() {
		var i Measurement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.MeasurementDate,
			&i.MeasurementTime,
			&i.Pressure1,
			&i.Pressure2,
			&i.Temperature1,
			&i.Temperature2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMeasurementsByDate = `-- name: GetMeasurementsByDate :many
SELECT id, created_at, measurement_date, measurement_time, pressure_1, pressure_2, temperature_1, temperature_2
FROM measurements
WHERE measurement_date BETWEEN $1 AND $2
`

type GetMeasurementsByDateParams struct {
	MeasurementDate   time.Time
	MeasurementDate_2 time.Time
}

func (q *Queries) GetMeasurementsByDate(ctx context.Context, arg GetMeasurementsByDateParams) ([]Measurement, error) {
	rows, err := q.db.QueryContext(ctx, getMeasurementsByDate, arg.MeasurementDate, arg.MeasurementDate_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Measurement
	for rows.Next() {
		var i Measurement
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.MeasurementDate,
			&i.MeasurementTime,
			&i.Pressure1,
			&i.Pressure2,
			&i.Temperature1,
			&i.Temperature2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
